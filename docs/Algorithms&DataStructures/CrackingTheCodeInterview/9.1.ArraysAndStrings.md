# Arrays and Strings

Let's take a look at some of the more common techniques and issues with these data structures.

## Hash Tables

A hash table is a data structure that maps keys to values for highly efficient lookup. So this is
similar to dictionaries.

Hash tables benefit from fast data retrieval and are foundational to standard tools and techniques
like caching and database indexing.

There are a number of ways of implementing this. Here let's see a common but simple interpretation.

In this implementation a array of linked list and a hash code function are used. To insert a key - which
might be a string or essentially any other data type) and value, this is what is done:

1. First, compute the key's hash code, which will usually be an int or long. Note that two different keys
could have the same hash code, as there may be an infinite number of keys and a finite number of ints.
2. Then, map the hash code to an index in the array. This could be done with something like `hash (key) % array_length`. Two different hash codes could, of course, map to the same index.
3. At this index, there is a linked list of keys and values. Store the key and value in this index. We must
use a linked list because of collisions: you could have two different keys with the same hash code, or two
different hash codes that map to the same index.

To retrieve the value by its key, you repeat this process. Compute the hash code from the key, and then
compute the index from the hash code. Then, search through the linked list for the value with this key.

If the number of collisions is very high, the worse case runtime is O(N), where N is the number of keys. However, we generally assume a good implementation that keeps collisions to a minimum, in which case the
look up time is O(1).

Alternatively, we can implement the hash table with a balanced binary search tree. This gives us an O(log N) lookup time. The advantage of this is potentially using less space, since we no longer allocate a large
array. We can also iterate through the keys in order, which can be useful sometimes.

## ArrayList & Resizable Arrays

In some languages, arrays (often called lists in this case) are automatically resizable. The array or list
will grow as you append items. In other languages, like Java, arrays are fixed length. The size is defined when you create the item.

When you need an array-like data structure that offers dynamic resizing, you would usually use an ArrayList. An ArrayList is an array that resizes itself as needed while still providing O(1) access. A
typical implementation is that when the array is full, the array doubles in size. Each doubling takes O(n),
but happens so rarely that its amortized insertion time is still O(1).

```java
ArrayList<String> merge(String[] words, String[] more) {
	ArrayList<String> sentence = new ArrayList<String>();
	for (String w : words) sentence.add(w);
	for (String w : more) sentence.add(w);
	return sentence;
}
```

This is an essential data structure for interviews. Be sure you are comfortable with dynamically resizable
arrays/lists in whatever language you will be working with. Note that the name of the data structure as well as the "resizing factor" (which is 2 in Java) can vary. In C#, the data structure is also called
`ArrayList` and it also doubles every time capacity is exceeded.

```csharp
ArrayList resizableArray = new(1); // The '1' passed to the constructor is the initial capacity. Optional.
resizableArray.Add(1);
Console.WriteLine($"Capacity: {resizableArray.Capacity} - Count: {resizableArray.Count}");
resizableArray.Add(2);
Console.WriteLine($"Capacity: {resizableArray.Capacity} - Count: {resizableArray.Count}");
resizableArray.Add(2);
Console.WriteLine($"Capacity: {resizableArray.Capacity} - Count: {resizableArray.Count}");
Console.WriteLine(resizableArray[2]);

// Result
// Capacity: 1 - Count: 1
// Capacity: 2 - Count: 2
// Capacity: 4 - Count: 3
// 2
```
