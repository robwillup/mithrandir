# Introduction to Algorithm Design

What is an algorithm? An algorithm is a procedure to accomplish a specific task.

An algorithm must solve a general, well-specified problem. An algorithmic problem is specified by describing the complete set of instances it must work on and of its output after running on one of these instances.

> So to have an algorithm, I must know what is the general problem it's trying to solve. For example, searching, ordering, etc. And instances of that problem, e.g.: ordering a string, searching of an integers in an unordered list, etc.

An algorithm is a procedure that takes any of the possible input instances and transforms it to the desired
output. There are many different algorithms for solving the problem of sorting. For example, insertion
sort is a method for sorting that starts with a single element (thus forming a trivially sorted list) and
then incrementally, inserts the remaining elements so that the list stays sorted.

```c
insertion_sort(item s[], int n)
{
	int i, j;

	for (i=1; i < n; i++) {
		while((j > 0) && (s[j] < s[j-1])) {
			swap(&s[j], &s[j-1]);
			j = j-1;
		}
	}
}
```

Note the generality of this algorithm. It works just as well on names as it does on numbers, given the
appropriate comparison operation (<) to test which of the two keys should appear first in sorted order.
It can be readily verified that this algorithm correctly orders every possible input instance according to our
definition of the sorting problem.

There are three desirable properties for a good algorithm. We seek algorithms that are **correct** and **efficient**, while being **easy to implement**. These goals may not be simultaneously achievable. In
industrial settings, any program that seems to give good enough answers without slowing the application down
is often acceptable, regardless of whether a better algorithm exists. The issue of finding the best
possible answer to achieving maximum efficiency usually arises in industry only after serious performance
or legal troubles.

## Robot Tour Optimization

The quest for an efficient algorithm to solve the `traveling salesman problem` will take us through much of this book.

There is a fundamental difference between algorithms, which always produce a correct result, and
heuristics, which may usually do a good job but without providing any guarantee.

Always try to consider this format for creating an algorithm:

*Problem:* Scheduling Problem
*Input:* A set I of n intervals on the line
*Output:* Largest subset of mutually non-overlapping intervals which can be selected from I

