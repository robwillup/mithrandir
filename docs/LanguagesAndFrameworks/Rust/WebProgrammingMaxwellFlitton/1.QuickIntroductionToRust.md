# Quick Introduction to Rust

Rust is described as having a steep learning curve.

The following topics will be covered here:

* Reviewing data types and variables in Rust
* Controlling variable ownership
* Building structs
* Metaprogramming with macros

## Why Rust?

With programming, there is usually a trade-off between speed/resources and development speed/safety.
Low-level languages such as C and C++ can give the developer fine grained control over the computer
with fast code execution and minimal resource consumption. However, this is not free. Manual memory
management can induce bugs and security vulnerabilities. On top of this, it takes more time and code
to solve a problem in a low-level language. As a result of this, C++ web frameworks do not take up
a large share of web development. Instead, it made sense to go for high-level programming languages
where developers can solve problems safely and quickly.

However, it has to be noted that this memory safety comes at a cost. Languages such as Python,
JavaScript, PHP, and Java keep track of all variables defined and their address, the data in that
memory address. When there are no more variables pointing to a memory address, the data in that
memory address gets deleted. This process is called garbage collection and consumes extra resources
and time.

With Rust, memory safety is ensured without the costly garbage collection process. Instead, the
compiler maps the variable, enforcing rules to ensure safety via a mechanism called the borrow
checker. Because of this, Rust has enabled rapid, safe problem solving with truly performant code,
thus breaking the speed/safety trade-off. As more data processing, traffic, and complex tasks are
lifted into the web stack, Rust, with its growing number of web frameworks and libraries, has now
become a viable choice for web development.

## Using Strings in Rust

```rust
fn print(input_string: String) {
    println!("{}", input_string);
}

fn main() {
    let test_string = String::from("Hello, Rob!");
    print(test_string);
}
```

The above code compiles and runs. Here we define a string using the `from` function in the `String`
object, and then passed it through our own `print` function to print it using Rust's built-in
`println!` function. (Technically, this is a macro; ! denotes that we can put multiple parameters
inside the parentheses).

Notice that the `print` function expects the `String` object to be passed through. If we try to
pass a literal string to that function it will throw the error:
`Expected 'String' found '&str' arguments to this function are in correct.`

To understand this we need to have a high-level understanding of stack and heap memory.

Stack memory is fast, static, and allocated at compile time. Heap memory is slower and allocated
at runtime. String literals can vary in side as they are the strings that we refer to, i.e.,
string literals are the actual strings, e.g. `A text` or `Another text` so their size will change.
String objects, on the other hand, have a fixed size in the stack that consists of a reference to
the string literal in the heap. When we pass a string literal to our own `print` function, it will
have no idea of the size of the string literal being passed through. String literals can be
converted into strings with `to_string`:

```rust
fn print(input_string: String) {
	println!("{}", input_string);
}

fn main() {
	print("Hello, Rob!".to_string());
}
```

In the example above, we converted the string literal into a string object just before passing it
through the print function.

We can also get the print function to accept a string literal reference by borrowing it using the
`&` operator:

```rust
fn print(input_string: &str) {
    println!("{}", input_string);
}

fn main() {
    print("Hello, Rob");
}
```

To get the string literal from an string object use the `as_str` method.

```rust
fn print(input_string: &str) {
    println!("{}", input_string);
}

fn main() {
    print(String::from(":)").as_str());
}
```

## Understanding Integers and Floats

Rust has signed integers (denoted by i) and unsigned integers (denoted by u) that consist of
8, 16, 32, 64, and 128 bits. We need to understand the range of numbers allowed in terms of bits.
Because binary is either 0 or 1, we can calculate the integer range by raising 2 to the power of
the number of bits. For example, for 8 bits, 2 to the power of 8 equates to 256. Considering the
0, this means that an u8 integer should have a range of 0 to 255:

```rust
let number: u8 = 255;
```

```rust
let number: i8 = 127;
```

In terms of floats, Rust accommodates f32 and f64 floating points, which can be both negative and
positive. Declaring a floating-point variable requires the same syntax as integers:

```rust
let float: f32 = 20.6;
```

It is also possible to annotate numbers with suffixes:

```rust
let x - 1u8; // x has the value of an 8-bit unsigned integer 1,
```

## Storing data in vectors and arrays

Rust stores sequenced data in vectors and arrays. Arrays are generally immutable and don't have push
functions. They also only accommodate one data type. This can be managed using structs and traits.
You can define and loop through arrays with fairly standard syntax:

```rust
fn main() {
    let int_array: [i32; 3] = [1, 2, 3];

    for i in int_array.iter() {
        println!("{}", i);
    }

    let str_vector: Vec<&str> = vec!["one", "two", "three"];

    for i in str_vector.iter() {
        println!("{}", i);
    }

    println!("{}", str_vector[1]);
}
```

By default variables defined in Rust are not mutable. To change that we need to put the `mut` keyword
in front of the variable's name:

```rust
let mut str_vector: Vec<&str> = vec!["one", "two", "three"];
```

This also works for strings and numbers. While it might be tempting to define everything as `mut`, this
forced immutability not only has performance benefits, but it also improves the safety. If you are not
expecting a variable to change in a complex system, then not allowing it to mutate will throw up the
error right then as opposed to allowing silent bugs to run in your system.

## Mapping data with hash maps

In some languages, hash maps are referred to as dictionaries. In order to define a hash map in Rust, we
must import the hash maps from the standard library. Once we've defined a new hash map, we can insert
and entry, get it out of the hash map, and then print it:

```rust
use std::collections::HashMap;

fn main() {
    let mut general_map: HashMap<&str, i8> = HashMap::new();
    general_map.insert("test", 25);
    let outcome: Option<&i8> = general_map.get("test");
    println!("{}", outcome.unwrap());
}
```

The `get` method from the HashMap does not return the type that was used in the declaration, instead it
returns an `Option` enum instead. This is because the `get` method could fail. We could pass it a key
that does not exist. Therefore we have to unwrap the option to get the value that we're aiming to get.
However, directly unwrapping the result can result in an error being raised. Because `Optional` is
either `Some` or `None`, we can explore Rust's `match` statement to handle the outcome:

```rust
use std::collections::HashMap;

fn main() {
    let mut general_map: HashMap<&str, i8> = HashMap::new();
    general_map.insert("test", 25);
    match general_map.get("tist") {
        None => println!("It failed."),
        Some(result) => println!("Here is the result: {}.", result)
    }
}
```

The arrows in the match statement can have their own code blocks.

Calling the `insert` function again with the same key will merely update the value under that key.
Calling the `remove` function from the hash map with the desired key will remove the entry if it
exists.

[HashMap Docs](https://doc.rust-lang.org/beta/std/collections/struct.HashMap.html).

## Handling Results and Errors

Like other languages, Rust throws and handles errors. It manages errors through two different types:
`Option` and `Result`. `Option` only returns `None` or `Some`. `Result` only returns `Err` or `Some`.

These are fairly similar, however, if `Err` is exposed, the `Rust` program panics and the program
crashes with what is the outcome of `Err`. While there will be plenty of opportunities to throw
errors, we will also want to throw our own when needed. When system becomes more complex, it can be
handy to purposefully throw errors if there is any undesired behavior. A good example is inserting
data into a Redis cache.

Technically, there is nothing stopping us from inserting a range of keys into Redis. In order to
prevent this, if the key is not an expected variant of what we want, we should throw an error.
Let's demonstrate how to throw an error, depending on the data:

```rust
fn error_check(check: bool) -> Result<i8, &'static str> {
    if check == true {
        Err("This is an error.")
    } else {
        Ok(1)
    }
}

fn main() {
    let result: i8 = error_check(true).unwrap();
    println!("{}", result);
}
```

Note that there is no `return` keyword. This is because the function returns the final expression
in the function when there is no semicolon at the end of the expression.

This `Result`